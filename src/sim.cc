#include <iostream>
#include <fstream>
#include <set>
#include <sstream>
#include <vector>

#include <gflags/gflags.h>
#include <glog/logging.h>

#include "message.h"
#include "node.h"

// Experiment Setup.
DEFINE_int32(nracks, 1, "#racks.");
DEFINE_int32(nodes_per_rack, 1, "#nodes per rack.");
DEFINE_int32(fanout, 2, "Fanout at rack-level.");

DEFINE_int64(msg_rate, 4000, "#messages generated by a node per second.");
DEFINE_int32(msg_size, 32, "Message size in bytes.");

DEFINE_int32(gc_policy, 0, "GC policy.");
DEFINE_int32(gc_delay, 10, "GC delay on each node in ms.");
DEFINE_int32(gc_period, 10, "GC interval.");

DEFINE_int64(in_limit, 1024 * 1024 * 1024 / 8,
    "Inbound BW limit per second at a node.");
DEFINE_int64(out_limit, 1024 * 1024 * 1024 / 8,
    "Outbound BW limit per second at a node.");
DEFINE_int64(in_limit_root, 1024 * 1024 * 1024 / 8,
    "Inbound BW limit per second at a node.");
DEFINE_int64(out_limit_root, 1024 * 1024 * 1024 / 8,
    "Outbound BW limit per second at a node.");

// System Parameters.
DEFINE_int64(duration, 60, "Duration of a simulation in seconds.");
DEFINE_int32(ticks, 1000, "#ticks in a second during simulation.");
DEFINE_int32(nthreads, 1, "Number of worker threads.");

int total_nodes;
std::vector<Node> nodes;

// Buffer for random keys.
struct KeyBuffer {
  int size, next, fid;
  std::vector<int64_t> data;
} keys;

void init() {
  keys.size = 1024 * 1024 * 1024;
  keys.size /= 32;
  keys.next = keys.size;
  keys.fid = -1;

  // TODO(haoyan): set the data rate for each node (msgs_per_tick)!

  total_nodes = FLAGS_nracks * FLAGS_nodes_per_rack;
  LOG(INFO) << "Simulate a datacenter with " << total_nodes << " nodes.";

  nodes = std::vector<Node>(total_nodes);
  for (auto& node : nodes) {
    node.msgs_per_tick = FLAGS_msg_rate / FLAGS_ticks;
  }

  // Construct a tree.
  // Within a rack, all the nodes send data to the first node in
  // the tree.
  // At rack-level, the first rack is selected as the root, and
  // we build the tree like a "heap" according to increasing
  // rack id.
  // The parennt of the root node is set to -1.
  int lo = 0, hi = 0;
  while (lo < total_nodes) {
    if (lo == 0) {
      nodes[0].p = -1;
      nodes[lo].in = nodes[lo].out = 0;
      nodes[lo].in_limit = FLAGS_in_limit_root / FLAGS_ticks;
      nodes[lo].out_limit = FLAGS_out_limit_root / FLAGS_ticks;
    } else {
      nodes[lo].in = nodes[lo].out = 0;
      nodes[lo].in_limit = FLAGS_in_limit / FLAGS_ticks;
      nodes[lo].out_limit = FLAGS_out_limit / FLAGS_ticks;
    }

    if (hi < total_nodes) {
      for (int i = 0; i < FLAGS_fanout; ++i) {
        hi += FLAGS_nodes_per_rack;
        if (hi >= total_nodes) break;
        nodes[hi].p = lo;
      }
    }

    for (int i = 1; i < FLAGS_nodes_per_rack; ++i) {
      nodes[lo + i].p = lo;
      nodes[lo + i].in = nodes[lo].out = 0;
      nodes[lo + i].in_limit = FLAGS_in_limit / FLAGS_ticks;
      nodes[lo + i].out_limit = FLAGS_out_limit / FLAGS_ticks;
      nodes[lo + i].gc = false;   // Leaf nodes should not do GC.
    }
    
    lo += FLAGS_nodes_per_rack;
  }

  for (int i = 0; i < total_nodes; i += FLAGS_nodes_per_rack) {
    LOG(INFO) << i << ' ' << nodes[i].p;
  }

  // Set up which nodes should perform Garbage Collections.

  switch (FLAGS_gc_policy) {
    case 0: // No GC.
      break;
    case 1: // Policy 1: all rack hubs perform GC.
      for (int i = 0; i < total_nodes; i += FLAGS_nodes_per_rack) {
        nodes[i].gc = true;
      }
      break;
    case 2: // Policy 2: only rack hubs at top 2 levels perform GC.
      for (int i = 0; i <= FLAGS_fanout; ++i) {
        nodes[i * FLAGS_nodes_per_rack].gc = true;
      }
      break;
    default:
  }
}

int64_t get_next_key() {
  if (keys.next == keys.size) {
    ++keys.fid;
    std::stringstream filename;
    filename << "data-" << keys.fid;

    std::fstream keyfile(filename.str());

    keys.data.clear();
    for (int i = 0; i < keys.size; ++i) {
      int64_t x;
      keyfile >> x;
      CHECK(x >= 0) << filename.str() << ' ' << i << ' ' << x;
      keys.data.push_back(x);
    }

    keyfile.close();

    keys.next = 1;
    CHECK(keys.data[0] >= 0) << 0 << ' ' << keys.data[0];
    return keys.data[0];
  }

  CHECK(keys.data[0] >= 0) << keys.next << ' ' << keys.data[keys.next];
  return keys.data[keys.next++];
}

void write_log(int t) {
  LOG(INFO) << (t / FLAGS_ticks) << " seconds";

  int64_t total_self = 0;
  int64_t total_saved = 0;
  for (int i = 0; i < total_nodes; ++i) {
    total_self += nodes[i].total_self_msgs;
    total_saved += nodes[i].msgs_saved;
    nodes[i].total_self_msgs = nodes[i].msgs_saved = 0;
  }

  LOG(INFO) << "Total messages generated: " << total_self;
  LOG(INFO) << "Total messages saved: " << total_saved;

  for (int i = 0; i < total_nodes; ++i) {
    if (i % FLAGS_nodes_per_rack == 0) {
      LOG(INFO) << "Node " << i
        << ' ' << double(nodes[i].in_per_sec) / (nodes[i].in_limit * FLAGS_ticks) * 100
        << ' ' << double(nodes[i].out_per_sec) / (nodes[i].out_limit * FLAGS_ticks) * 100;
    }
    nodes[i].in_per_sec = nodes[i].out_per_sec = 0;
  }
}

void simulate() {
  int64_t duration_ms = FLAGS_duration * FLAGS_ticks;
  LOG(INFO) << "Simulate for " << duration_ms << " ticks...";

  for (int64_t t = 0; t < duration_ms; ++t) {
    // TODO: distribute nodes across a set of threads.
    for (int i = 0; i < total_nodes; ++i) {
//      LOG(INFO) << "Node " << i;
      nodes[i].in = nodes[i].out = 0;

      // Step 1: admit incoming messages until nothing left or we hit the BW limit.
      while (!nodes[i].q.empty() && nodes[i].in + FLAGS_msg_size <= nodes[i].in_limit) {
        Message msg = nodes[i].q.front();
        if (nodes[i].gc) {
          msg.time = t + FLAGS_gc_delay;
        } else {
          msg.time = t;
        }

        nodes[i].buf.push_back(msg);
        nodes[i].q.pop();
        nodes[i].in += FLAGS_msg_size;
        ++nodes[i].total_in_msgs;
      }
      nodes[i].in_per_sec += nodes[i].in;

//      LOG(INFO) << "Step 1 done.";

      // Step 2: generate its own messages at a certain rate.
      for (int j = 0; j < nodes[i].msgs_per_tick; ++j) {
        Message msg;
        msg.type = 0;
        msg.key = get_next_key();
        if (nodes[i].gc) {
          msg.time = t + FLAGS_gc_delay;
        } else {
          msg.time = t;
        }

        nodes[i].buf.push_back(msg);
        ++nodes[i].total_self_msgs;
      }

//      LOG(INFO) << "Step 2 done.";

      // Step 3: process buffered messages if necessary (e.g. GC).
      // TODO(haoyan).
      if (nodes[i].gc && t % FLAGS_gc_period == 0 && !nodes[i].buf.empty()) {
        int pos = int(nodes[i].buf.size()) - 1;
/*
        LOG(INFO) << "Keys:";
        for (int j = 0; j < pos + 1; ++j) {
          if (nodes[i].buf[j].type != 0) {
            LOG(INFO) << "TS";
          } else {
            LOG(INFO) << nodes[i].buf[j].key;
          }
        }
*/
        std::set<int> table;
        while (pos >= 0) {
          if (nodes[i].buf[pos].type == 0) {
            if (table.count(nodes[i].buf[pos].key) == 1) {
              nodes[i].buf[pos].type = 1;
            } else {
              table.insert(nodes[i].buf[pos].key);
            }
          }
          --pos;
        }

        pos = int(nodes[i].buf.size());
        int flag = 0;
        int saved = 0;
        for (int j = 0; j < pos; ++j) {
          if (nodes[i].buf[j].type == 1) {
            if (flag == 0) {
              flag = 1;
            } else {
              nodes[i].buf[j].type = 2;
              ++saved;//nodes[i].msgs_saved;
            }
          } else if (nodes[i].buf[j].type == 0) {
            flag = 0;
          }
        }
        nodes[i].msgs_saved += saved;
        LOG(INFO) << "GC at node " << i << ": " << saved << "/" << pos << ".";
      }

//      LOG(INFO) << "Step 3 done.";

      // Step 4: emit outgoing messages to other nodes until everything is done or we hit the BW limit.
      while (!nodes[i].buf.empty()
          && nodes[i].buf.front().time <= t
          && nodes[i].out + FLAGS_msg_size <= nodes[i].out_limit) {
        if (nodes[i].buf.front().type != 2) {
          if (nodes[i].p != -1) {
            nodes[nodes[i].p].q.push(nodes[i].buf.front());
          }
          nodes[i].out += FLAGS_msg_size;
          ++nodes[i].total_out_msgs;
        }
        nodes[i].buf.pop_front();
      }
      nodes[i].out_per_sec += nodes[i].out;

//      LOG(INFO) << "Step 4 done.";
    }

    // Gather log information.
    if (t != 0 && t % FLAGS_ticks == 0) {
      write_log(t);
    }
  }

  write_log(duration_ms);
}

int main(int argc, char **argv) {
  google::ParseCommandLineFlags(&argc, &argv, true);

  FLAGS_logtostderr = 1;
  google::InitGoogleLogging(argv[0]);

  init();
  simulate();
}
